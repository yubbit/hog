import numpy as np
import cv2
import timeit

def hog(img,
        cell_sz=8,
        block_sz=2,
        nbins=9):

    sz_y = img.shape[0]
    sz_x = img.shape[1]
    sz_ch = img.shape[2]

    # Generates a set of vectors on the unit circle. Gradients generated by the Sobel filter will
    # be projected onto these to determine which bin they should be allocated to
    bin_range = np.arange(nbins) * np.pi / nbins - np.pi / 2
    gradient_bin = np.stack((np.sin(bin_range), np.cos(bin_range)))

    # Generates the gradient filters
    sobel_y = np.array([1, 2, 1, 0, 0, 0, -1, -2, -1], dtype=np.float64).reshape(3,3)
    #sobel_y = np.array([1, 0, -1], dtype=np.float64).reshape(3,1)
    sobel_x = sobel_y.T

    # Calculates the vertical and horizontal gradients of the image
    # Note that the type is stored as np.uint8 by default, resulting in the values being
    # truncated to the range [0, 255]. The output type has to be explicitly specified
    g_y = cv2.filter2D(img, cv2.CV_64F, sobel_y)
    g_x = cv2.filter2D(img, cv2.CV_64F, sobel_x)

    # Calculates the magnitude of the gradient at each point, for each channel, then stores the
    # channel with the greatest magnitude at each point
    g_mag = g_y ** 2 + g_x ** 2
    g_mag = g_mag.reshape(sz_y, sz_x, sz_ch) # Reshape in case the input is 1 channel, otherwise opencv removes the channel of size 1
    g_mag_ch = g_mag.argmax(axis=2)

    # Projects the gradients onto the vectors in gradient_bin, then retrieves the bin for which
    # the magnitude of the projection is the greatest
    g_proj = np.stack((g_y, g_x), axis=-1)
    g_proj = np.abs(g_proj.dot(gradient_bin))
    g_proj = g_proj.reshape(sz_y, sz_x, sz_ch, nbins) # Reshape in case the input is 1 channel, otherwise opencv removes the channel of size 1
    g_proj_ch = g_proj.argmax(axis=3)

    # Generates the cell histogram matrix
    cell_hist_sz_y = np.floor(sz_y / cell_sz).astype(np.uint16)
    cell_hist_sz_x = np.floor(sz_x / cell_sz).astype(np.uint16)
    cell_hist = np.zeros((cell_hist_sz_y, cell_hist_sz_x, nbins))

    # Calculates the cell histogram matrix. Takes the channel with the highest magnitude at each
    # point, and adds it to the bin of the angle to which it projects the highest value
    for i in range(cell_hist_sz_y):
        for j in range(cell_hist_sz_x):
            for ii in range(cell_sz):
                for jj in range(cell_sz):
                    y_pos = i * cell_sz + ii
                    x_pos = j * cell_sz + jj

                    mag_ch = g_mag_ch[y_pos, x_pos]
                    orient = g_proj_ch[y_pos, x_pos, mag_ch]

                    cell_hist[i, j, orient] += g_mag[y_pos, x_pos, mag_ch]

    # Generates the output feature matrix
    block_diff = block_sz - 1
    block_hist_sz_y = cell_hist_sz_y - block_diff
    block_hist_sz_x = cell_hist_sz_x - block_diff
    block_hist = np.zeros((block_hist_sz_y, block_hist_sz_x, block_sz ** 2 * nbins))

    # Normalizes the cells by block, and stores the normalized vectors as the block's channels
    for i in range(cell_hist_sz_y - block_diff):
        for j in range(cell_hist_sz_x - block_diff):
            block = cell_hist[i:i+block_sz, j:j+block_sz,:].flatten()
            block_hist[i, j, :] = block / np.linalg.norm(block)

    return block_hist


if __name__ == '__main__':
    start = timeit.default_timer()
    for i in range(100):
        img = cv2.imread('test.jpg')
        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        img = cv2.resize(img, dsize=(0, 0), fx=0.2, fy=0.2)
        #img = cv2.resize(img, (128, 128))
        img = img.reshape(img.shape[0], img.shape[1], -1)
        test = hog(img)
    print((timeit.default_timer() - start) / 100)

